# -*- coding: utf-8 -*-
"""Text_Extraction + Translation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IQ6fOU9Jw3_gc7U0FUCTA3oT6LvIt7zd
"""

import fitz
import re
import math

# Function to extract all the vector text with their location

def extract_text_with_location(doc):
    """Extracts all text and their locations from a PDF document."""
    extracted_text_with_location = []
    for page_num in range(doc.page_count):
        page = doc[page_num]
        words = page.get_text("words") # (x0, y0, x1, y1, word, word_no, block_no, line_no)
        for word in words:
            extracted_text_with_location.append({
                "text": word[4],
                "bbox": (word[0], word[1], word[2], word[3]),
                "page": page_num
            })
    return extracted_text_with_location


# Function to filter the Chinese text from all the extracted text

def filter_chinese_text(extracted_data):
    """Filters the extracted text to keep only likely Chinese text."""
    extracted_chinese_text_with_location = []
    for item in extracted_data:
        if is_likely_chinese(item["text"]):
            extracted_chinese_text_with_location.append(item)
    return extracted_chinese_text_with_location


# Helper function for filtering chinese text

def is_likely_chinese(text):
    """Checks if a string likely contains Chinese characters."""
    # A simple check using a common Unicode range for Chinese characters
    chinese_chars = re.findall(r'[\u4e00-\u9fff]', text)
    # Consider a word likely Chinese if it contains at least one Chinese character
    return len(chinese_chars) > 0



from transformers import AutoTokenizer, AutoModelForSeq2SeqLM

# Load model + tokenizer for Chinese to English translation
local_model_path = "./offline_model"
translator_tokenizer = AutoTokenizer.from_pretrained(local_model_path)
translator_model = AutoModelForSeq2SeqLM.from_pretrained(local_model_path)


# Function to translate the Chinese text to English

def translate_chinese_to_english(chinese_text_data):
    """Translates extracted Chinese text to English."""
    translated_data = []
    for item in chinese_text_data:
        chinese_text = item["text"]
        try:
            # Prepare input for the model
            input_ids = translator_tokenizer(chinese_text, return_tensors="pt").input_ids

            # Generate translation
            translated_ids = translator_model.generate(input_ids, max_length=512)

            # Decode the translated text
            english_text = translator_tokenizer.decode(translated_ids[0], skip_special_tokens=True).strip()

        except Exception as e:
            print(f"Error translating '{chinese_text}': {e}")
            english_text = "" # Assign empty string in case of error

        # Debugging print statement
        # print(f"Chinese: '{chinese_text}' -> English: '{english_text}'")

        translated_data.append({
            "text": chinese_text,
            "bbox": item["bbox"],
            "page": item["page"],
            "english_translation": english_text
        })
    return translated_data

# Function to overlay a solid box and translations and create an output PDF

def create_translated_pdf(doc, translated_data, output_filename="translated_output.pdf"):
    """
    Creates a new PDF with Chinese text replaced by English translations.
    """
    # Create a new PDF to save the output
    output_doc = fitz.open()

    for page_num in range(doc.page_count):
        # Get the original page and copy it to the new document
        page = doc[page_num]
        output_page = output_doc.new_page(width=page.rect.width, height=page.rect.height)
        output_page.show_pdf_page(page.rect, doc, page_num) # Copies everything (text, images, etc.)

        # Process each translated item for the current page
        for item in translated_data:
            if item["page"] == page_num:
                original_bbox = fitz.Rect(item["bbox"])
                print(item['english_translation'])
                english_text = item["english_translation"]

                # 1. Hide the original text by drawing a white box over it
                # The color and fill are both white (1, 1, 1) to completely cover the text
                output_page.draw_rect(original_bbox, color=(1, 1, 1), fill=(1, 1, 1), overlay=True)

                # 2. Use the formula to get the best font size for a single line
                best_fsize = get_optimal_fontsize(original_bbox, english_text)
                print(f"Best font size for '{english_text}': {best_fsize} : {type(best_fsize)}")

                # 3. Insert the translated English text into the same bounding box
                # You may need to adjust the fontsize for the text to fit well.
                # 'fontsize=0' tells PyMuPDF to find the best font size.
                output_page.insert_textbox(
                    original_bbox,
                    english_text,
                    fontsize=best_fsize,
                    fontname="helv",  # A standard, safe font like Helvetica
                    color=(0, 0, 0), # Black text color
                    overlay=True
                )

    # Save the final translated PDF
    print(f"Saving translated PDF to '{output_filename}'...")
    output_doc.save(output_filename)
    output_doc.close()
    print("Done.")


# Helper function to calculate the optimal font size

def get_optimal_fontsize(rect, text, fontname="helv", max_fontsize=12):
  """
  Calculates the optimal font size to fit text into a rect on a single line.
  """
  # 1. Calculate the text's length at a baseline font size of 1
  text_len_at_size_1 = fitz.get_text_length(text, fontname=fontname, fontsize=1)

  # 2. Avoid a division by zero error for empty strings
  if text_len_at_size_1 == 0:
      return max_fontsize  # Return a default size

  # 3. Calculate the theoretical optimal font size
  optimal_size = rect.width / text_len_at_size_1

  # 4. Return the calculated size, but don't exceed the specified max_fontsize
  return min(math.floor(optimal_size), max_fontsize)




# The main process flow function

def main_process(pdf_path="uploaded_pdf.pdf"):
    """Main process to extract, filter, translate, and visualize Chinese text in a PDF."""
    extracted_all_text = []
    extracted_chinese_text = []
    translated_chinese_text = []

    try:
        doc = fitz.open(pdf_path)

        # 1. Extract all text with locations
        print('extracting all text from the vector PDF...\n')
        extracted_all_text = extract_text_with_location(doc)

        # 2. Filter for Chinese text
        print("Filtering out the Chinese text from the extracted text...\n")
        extracted_chinese_text = filter_chinese_text(extracted_all_text)

        # 3. Translate Chinese text to English
        print("Translating the Chinese text to English...\n")
        translated_chinese_text = translate_chinese_to_english(extracted_chinese_text)

        # # 4. Draw bounding boxes around Chinese text and save
        # print("Drawing the bounding box around detected Chinese text...\n")
        # draw_bounding_boxes(doc, extracted_chinese_text, output_filename="output_with_bboxes_chinese_text.pdf")

        # 4. Overlaying a solid box and translations and creating an output PDF
        print("Creating an output PDF with translated Chinese text...\n")
        create_translated_pdf(doc, translated_chinese_text)

        doc.close()

    except FileNotFoundError:
        print(f"Error: '{pdf_path}' not found. Please upload the PDF file.")
    except Exception as e:
        print(f"An error occurred: {e}")

    return translated_chinese_text

# Run the main process
translated_chinese_text_with_location = main_process()